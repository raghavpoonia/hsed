# section_1_02_chmod_analogy.yaml
---
document_info:
  chapter: "1"
  section: "02"
  title: "The chmod Analogy: From rwx to HSED"
  version: "1.0.0"
  author: "Raghav Dinesh"
  github: "github.com/raghavpoonia"
  license: "MIT"
  created: "2025-12-29"
  estimated_pages: 6
  tags: ["hsed", "chmod", "unix-permissions", "analogy", "mental-model"]

# ============================================================================
# SECTION 1.02: THE CHMOD ANALOGY - FROM RWX TO HSED
# ============================================================================

section_1_02_chmod_analogy:
  
  # --------------------------------------------------------------------------
  # Overview and Context
  # --------------------------------------------------------------------------
  
  overview: |
    Every Unix user learns chmod in their first week. You see `chmod 755 script.sh` 
    and you immediately know:
    - Owner can read, write, execute (7 = rwx)
    - Group can read, execute (5 = r-x)
    - Others can read, execute (5 = r-x)
    
    No confusion. No documentation lookup. Just three bits per entity, composed 
    using simple octal arithmetic. This elegant model has secured Unix systems 
    for over 50 years.
    
    HSED (Hash|Sign|Encrypt|Decrypt) applies the same principles to cryptographic 
    operations. Just as chmod has three permission bits (rwx), HSED has four 
    permission bits (HSED). Just as chmod uses octal notation (0-7), HSED uses 
    octal notation (0-15).
    
    This section establishes the mental model: if you understand chmod, you 
    understand HSED. The analogy isn't superficial - it's structural. We're 
    taking a proven permission model and adapting it to a new domain.
  
  # --------------------------------------------------------------------------
  # Core Concepts
  # --------------------------------------------------------------------------
  
  core_concepts:
    
    chmod_fundamentals:
      
      definition: |
        chmod (change mode) is the Unix command for setting file permissions. 
        It uses a 3-bit model where each bit represents a distinct operation:
        
        - **r (read)** = 4 = Binary 100 = View file contents
        - **w (write)** = 2 = Binary 010 = Modify file contents
        - **x (execute)** = 1 = Binary 001 = Run file as program
        
        These three bits combine using simple addition:
        - rwx = 4+2+1 = 7
        - rw- = 4+2 = 6
        - r-x = 4+1 = 5
        - r-- = 4
        
        The model applies to three entities (owner, group, others), giving us 
        the familiar three-digit notation: chmod 755, chmod 644, etc.
      
      why_it_matters: |
        chmod succeeded where other permission models failed because:
        
        1. **Limited operations**: Only 3 permissions, not 20+
        2. **Binary composition**: Permissions combine via bitwise OR
        3. **Octal shorthand**: 3 bits = 1 octal digit (0-7)
        4. **Clear semantics**: Read means read, write means write
        5. **Mental computation**: You can calculate 'rwx' = 7 in your head
        6. **Universal adoption**: Same model everywhere for 50+ years
        
        These aren't accidents - they're design principles that made chmod the 
        most successful permission model in computing history.
      
      key_components:
        
        read_permission:
          what: "View file contents"
          bit_value: 4
          binary: "100"
          operations_allowed:
            - "cat filename"
            - "less filename"
            - "grep pattern filename"
          security_boundary: "Information disclosure control"
        
        write_permission:
          what: "Modify file contents"
          bit_value: 2
          binary: "010"
          operations_allowed:
            - "echo data > filename"
            - "vim filename"
            - "rm filename"
          security_boundary: "Data integrity control"
        
        execute_permission:
          what: "Run file as program"
          bit_value: 1
          binary: "001"
          operations_allowed:
            - "./script.sh"
            - "/usr/bin/program"
          security_boundary: "Code execution control"
      
      how_it_works: |
        chmod uses positional octal notation:
        
        ```
        chmod 755 filename
              ^^^
              |||
              ||└─ Others: 5 = r-x (read + execute)
              |└── Group:  5 = r-x (read + execute)
              └─── Owner:  7 = rwx (read + write + execute)
        ```
        
        Each position is independent. To compute a permission value:
        
        1. Start with 0
        2. Add 4 if read needed
        3. Add 2 if write needed
        4. Add 1 if execute needed
        
        Example: Script that owner can modify and everyone can run
        - Owner: read + write + execute = 4+2+1 = 7
        - Group: read + execute = 4+1 = 5
        - Others: read + execute = 4+1 = 5
        - Result: `chmod 755 script.sh`
      
      real_world_example: |
        **Common chmod patterns and their meanings:**
        
        **chmod 644 document.txt**
        - Owner: rw- (6 = can edit document)
        - Group: r-- (4 = can read document)
        - Others: r-- (4 = can read document)
        Use case: Documentation, configuration files
        
        **chmod 600 secret.key**
        - Owner: rw- (6 = can read and update key)
        - Group: --- (0 = no access)
        - Others: --- (0 = no access)
        Use case: Private keys, credentials
        
        **chmod 755 deploy.sh**
        - Owner: rwx (7 = can modify and run script)
        - Group: r-x (5 = can run script)
        - Others: r-x (5 = can run script)
        Use case: Deployment scripts, utilities
        
        **chmod 700 admin-tool**
        - Owner: rwx (7 = full control)
        - Group: --- (0 = no access)
        - Others: --- (0 = no access)
        Use case: Administrative tools, sensitive operations
        
        Each pattern is immediately recognizable and conveys intent clearly.
      
      related_concepts:
        - "Principle of least privilege: Grant minimum necessary permissions"
        - "Bit masking: Using binary operations to combine permissions"
        - "Octal arithmetic: Base-8 numbering system"
    
    mapping_files_to_crypto:
      
      definition: |
        File operations and cryptographic operations have structural similarities 
        that make the chmod analogy more than superficial:
        
        **File operations:**
        - Read: View information without modifying
        - Write: Change information
        - Execute: Use information to perform action
        
        **Crypto operations:**
        - Hash/Verify: Examine cryptographic properties without authority
        - Sign: Create cryptographic proof (authority)
        - Encrypt: Transform data (create confidentiality)
        - Decrypt: Reverse transformation (access confidentiality)
        
        Both domains involve controlling access to operations on protected 
        resources. Both require balancing security (limit access) with 
        functionality (enable legitimate use).
      
      why_it_matters: |
        The analogy works because:
        
        1. **Operations are atomic**: Both chmod and HSED define indivisible 
           operations. You can't "half-read" a file or "partially decrypt" data.
        
        2. **Operations compose**: In chmod, rwx = r + w + x. In HSED, 
           permissions combine the same way using bit operations.
        
        3. **Access control patterns repeat**: Just as some files are read-only 
           (r--) and others are read-write (rw-), some crypto operations are 
           verify-only (H) while others allow full authority (HSED).
        
        4. **Security principles transfer**: Least privilege, separation of 
           duties, defense in depth - all apply equally to files and crypto.
        
        Understanding this structural similarity makes HSED immediately intuitive 
        for anyone who knows chmod.
      
      key_components:
        
        read_to_hash:
          chmod_operation: "Read (r)"
          hsed_operation: "Hash (H)"
          similarity: "Both examine without modifying or asserting authority"
          example: |
            File: cat file.txt → View contents, can't modify
            Crypto: verify_signature(data) → Check validity, can't create signatures
        
        write_to_sign_encrypt:
          chmod_operation: "Write (w)"
          hsed_operations: "Sign (S) + Encrypt (E)"
          similarity: "Both create or modify, requiring authority"
          example: |
            File: echo "data" > file.txt → Modify contents (needs write)
            Crypto: sign(data) → Create signature (needs sign authority)
                    encrypt(data) → Create ciphertext (needs encrypt authority)
        
        execute_to_decrypt:
          chmod_operation: "Execute (x)"
          hsed_operation: "Decrypt (D)"
          similarity: "Both use resource to perform action"
          example: |
            File: ./program → Use file to execute code
            Crypto: decrypt(ciphertext) → Use key to access plaintext
      
      how_it_works: |
        Mapping chmod patterns to HSED roles:
        
        **chmod 644 (readable file):**
        ```
        Owner: rw- → Can read and modify
        Others: r-- → Can read only
        ```
        HSED equivalent: hsed:audit (H+D = 9)
        - Can verify signatures (like reading)
        - Can decrypt for audit (like reading with authorization)
        - Cannot sign or encrypt (no write authority)
        
        **chmod 755 (executable script):**
        ```
        Owner: rwx → Full control
        Others: r-x → Can read and execute
        ```
        HSED equivalent: hsed:signer (H+S = 12)
        - Can verify existing signatures (read)
        - Can create new signatures (execute authority)
        - Cannot decrypt secrets (execute doesn't mean decrypt)
        
        **chmod 600 (private file):**
        ```
        Owner: rw- → Exclusive read/write
        Others: --- → No access
        ```
        HSED equivalent: hsed:vault (E+D = 3)
        - Can encrypt data (exclusive write)
        - Can decrypt data (exclusive read)
        - Cannot verify or sign (no read/execute for others)
      
      real_world_example: |
        **Scenario: Multi-tier web application**
        
        **File permissions:**
        ```bash
        # Application binary
        chmod 755 /usr/bin/webapp
        # Owner (deploy): rwx → Can deploy new versions
        # Service (run): r-x → Can execute, can't modify
        
        # Configuration
        chmod 640 /etc/webapp/config.yml
        # Owner (admin): rw- → Can update config
        # Service (read): r-- → Can read config only
        
        # Logs
        chmod 644 /var/log/webapp.log
        # Service (write): rw- → Can write logs
        # Auditors (read): r-- → Can read logs only
        ```
        
        **HSED permissions (equivalent pattern):**
        ```yaml
        # Deployment service
        hsed: signer (12 = H+S)
        # Can verify artifact signatures
        # Can sign new deployment attestations
        # Cannot decrypt production secrets
        
        # Application service
        hsed: vault (3 = E+D)
        # Can encrypt user data
        # Can decrypt user data
        # Cannot sign transactions (that's separate service)
        
        # Audit service
        hsed: audit (9 = H+D)
        # Can verify all signatures
        # Can decrypt for forensics
        # Cannot sign or encrypt (read-only from security perspective)
        ```
        
        Same pattern, different domain. The permission model translates directly.
      
      related_concepts:
        - "Domain transfer: Applying proven models to new contexts"
        - "Structural analogy: Similarity in organization, not just surface"
        - "Permission composition: Building complex access from simple primitives"
    
    why_four_bits_not_three:
      
      definition: |
        chmod uses 3 bits (rwx) because there are 3 fundamental file operations. 
        HSED uses 4 bits (HSED) because there are 4 fundamental cryptographic 
        operations.
        
        The question isn't "why more than chmod?" but "why these four operations?"
        
        Answer: These four operations cover the complete space of cryptographic 
        access control:
        
        1. **Hash (H)**: Verify cryptographic properties (read-only)
        2. **Sign (S)**: Create cryptographic proofs (write authority)
        3. **Encrypt (E)**: Seal data (write confidentiality)
        4. **Decrypt (D)**: Unseal data (read confidentiality)
        
        These aren't arbitrary - they're the minimal set that covers all KMS/HSM 
        operations while maintaining clear separation.
      
      why_it_matters: |
        Four bits gives us 2^4 = 16 possible combinations (0-15), which maps 
        perfectly to:
        - 0 = No permissions (revoked access)
        - 1-14 = Various useful combinations
        - 15 = Full authority (root/admin)
        
        This is just like chmod's 2^3 = 8 combinations (0-7):
        - 0 = No access (---)
        - 1-6 = Various combinations
        - 7 = Full access (rwx)
        
        The extra bit in HSED isn't bloat - it's necessary to properly separate 
        "sign" from "encrypt" and "verify" from "decrypt". These are distinct 
        operations with different security implications.
      
      key_components:
        
        hash_necessity:
          why_needed: "Verification without authority"
          without_it: "Can't verify signatures without also being able to sign (wrong!)"
          example: |
            CI/CD verification stage should verify signatures without signing 
            capability. Hash permission enables this.
        
        sign_necessity:
          why_needed: "Attestation authority separate from confidentiality"
          without_it: "Can't separate signing from encryption (wrong!)"
          example: |
            Code signing service should sign releases without access to decrypt 
            production secrets. Sign permission enables this.
        
        encrypt_necessity:
          why_needed: "Write confidentiality separate from read"
          without_it: "Can't write encrypted data without reading it (wrong!)"
          example: |
            Data ingestion service should encrypt incoming data without ability 
            to decrypt (one-way flow). Encrypt permission enables this.
        
        decrypt_necessity:
          why_needed: "Read confidentiality separate from all other operations"
          without_it: "Can't audit encrypted data without full crypto access (wrong!)"
          example: |
            Audit service should decrypt evidence without ability to sign or 
            encrypt. Decrypt permission enables this.
      
      how_it_works: |
        Four bits in HSED vs three in chmod:
        
        **chmod (3 bits, 8 combinations):**
        ```
        000 = 0 = ---  (no access)
        001 = 1 = --x  (execute only)
        010 = 2 = -w-  (write only - rare)
        011 = 3 = -wx  (write+execute - rare)
        100 = 4 = r--  (read only)
        101 = 5 = r-x  (read+execute - common)
        110 = 6 = rw-  (read+write - common)
        111 = 7 = rwx  (full access)
        ```
        
        **HSED (4 bits, 16 combinations):**
        ```
        0000 = 0  = ----  (no access)
        0001 = 1  = ---D  (decrypt only)
        0010 = 2  = --E-  (encrypt only)
        0011 = 3  = --ED  (vault: encrypt+decrypt)
        0100 = 4  = -S--  (sign only)
        0101 = 5  = -S-D  (sign+decrypt - rare)
        0110 = 6  = -SE-  (sign+encrypt - sealer)
        0111 = 7  = -SED  (sign+encrypt+decrypt - avoid)
        1000 = 8  = H---  (verify only)
        1001 = 9  = H--D  (audit: verify+decrypt)
        1010 = 10 = H-E-  (dmz: verify+encrypt)
        1011 = 11 = H-ED  (reader: verify+encrypt+decrypt)
        1100 = 12 = HS--  (signer: verify+sign)
        1101 = 13 = HS-D  (operator: verify+sign+decrypt)
        1110 = 14 = HSE-  (admin: verify+sign+encrypt)
        1111 = 15 = HSED  (root: full authority)
        ```
        
        Notice: Most useful combinations (3, 9, 10, 12, 15) have clear names 
        and use cases, just like chmod's common patterns (4, 5, 6, 7).
      
      real_world_example: |
        **Why three bits wouldn't work for crypto:**
        
        Imagine HSED with only 3 bits (trying to match chmod exactly):
        
        **Failed attempt - 3 bits:**
        ```
        Bit 1 = Verify/Hash (like read)
        Bit 2 = Sign/Encrypt (like write) ← Problem: conflates two operations!
        Bit 3 = Decrypt (like execute)
        ```
        
        **Problem scenario:**
        CI/CD pipeline needs to sign releases. Using 3-bit model:
        - Grant "Sign/Encrypt" permission (Bit 2)
        - Service can now sign releases ✓
        - Service can also encrypt arbitrary data ✗
        - Service might exfiltrate secrets by encrypting them ✗✗
        
        **With proper 4 bits:**
        ```
        CI/CD gets: H+S (12) = Verify + Sign
        - Can verify existing signatures ✓
        - Can sign new releases ✓
        - Cannot encrypt data ✓ (no E bit)
        - Cannot decrypt secrets ✓ (no D bit)
        ```
        
        The fourth bit isn't luxury - it's necessary for proper separation of 
        duties between signing (attestation) and encryption (confidentiality).
      
      related_concepts:
        - "Minimal sufficient set: Enough operations to cover all cases"
        - "Separation of concerns: Each bit controls distinct capability"
        - "Goldilocks principle: Not too few (incomplete), not too many (complex)"
  
  # --------------------------------------------------------------------------
  # Practical Implementation
  # --------------------------------------------------------------------------
  
  practical_implementation:
    
    translating_chmod_to_hsed:
      
      overview: "Mental model for converting chmod patterns to HSED roles"
      
      when_to_use:
        - "Designing HSED permissions for new system"
        - "Migrating existing file-based permissions to crypto"
        - "Explaining HSED to team familiar with chmod"
      
      step_by_step_process:
        
        step_1:
          action: "Identify chmod pattern you're familiar with"
          details: |
            Start with a chmod pattern that matches your use case:
            - Read-only? → Think chmod 444 or 644
            - Read-write? → Think chmod 600 or 644
            - Executable? → Think chmod 755 or 700
          success_criteria: "You have a chmod number in mind (e.g., 755)"
        
        step_2:
          action: "Map file operation to crypto operation"
          details: |
            Use this mapping:
            - Read (r) → Hash/Verify (H) = 8
            - Write (w) → Sign (S) + Encrypt (E) = 4+2 = 6
            - Execute (x) → Decrypt (D) = 1
            
            Note: Write splits into Sign and Encrypt because crypto distinguishes 
            attestation (sign) from confidentiality (encrypt).
          success_criteria: "You know which HSED bits you need"
        
        step_3:
          action: "Compute HSED octal value"
          details: |
            Add up bit values:
            - Need Hash? Add 8
            - Need Sign? Add 4
            - Need Encrypt? Add 2
            - Need Decrypt? Add 1
            
            Example: CI/CD needs to verify and sign
            - Hash: +8
            - Sign: +4
            - Total: 12 = hsed:signer
          success_criteria: "You have HSED octal number (0-15)"
        
        step_4:
          action: "Check against standard roles"
          details: |
            See if your computed value matches a standard role:
            - 15 = hsed:root (full authority)
            - 12 = hsed:signer (CI/CD, attestation)
            - 3 = hsed:vault (secrets management)
            - 9 = hsed:audit (compliance, forensics)
            - 10 = hsed:dmz (boundary, ingress)
            - 8 = hsed:verifier (signature check only)
            - 14 = hsed:admin (management without decrypt)
            
            If match: Use standard role name
            If no match: Use custom role with octal notation
          success_criteria: "You have role name or octal value"
        
        step_5:
          action: "Validate security properties"
          details: |
            Ask these questions:
            1. Can this role decrypt secrets? (D bit set?)
               - If yes: Extra scrutiny needed
            2. Can this role sign attestations? (S bit set?)
               - If yes: Audit trail critical
            3. Does this role combine incompatible operations?
               - Sign + Decrypt together (13) = Dangerous, needs justification
               - Encrypt-only (2) = Unusual, might be one-way data flow
            4. Is this the minimum necessary permission?
               - Could we reduce by removing one bit?
          success_criteria: "Security review passed"
      
      complete_example: |
        **Scenario: Deployment pipeline**
        
        **Traditional file permissions:**
        ```bash
        # Deployment script
        chmod 755 deploy.sh
        # Owner (CI/CD): rwx = Can modify and run
        # Others: r-x = Can run only
        ```
        
        **Translating to HSED:**
        
        Step 1: Identify pattern
        - chmod 755 = rwx for owner, r-x for others
        
        Step 2: Map operations
        - r (read) → H (verify) = 8
        - w (write) → S (sign) = 4  [we want attestation]
        - x (execute) → Not needed (we're not decrypting)
        
        Step 3: Compute value
        - H + S = 8 + 4 = 12
        
        Step 4: Check standard roles
        - 12 = hsed:signer ✓
        
        Step 5: Validate
        - Can decrypt? No (no D bit) ✓
        - Can sign? Yes (S bit) - appropriate for CI/CD ✓
        - Minimum necessary? Yes, needs verify + sign ✓
        
        **Result:**
        ```yaml
        ci_cd_pipeline:
          role: hsed:signer
          permissions: 12
          operations:
            - verify_artifact_signatures
            - sign_deployment_attestation
          cannot:
            - decrypt_production_secrets
            - encrypt_arbitrary_data
        ```
        
        Clean translation from chmod 755 to hsed:signer (12).
  
  # --------------------------------------------------------------------------
  # Comparisons and Trade-offs
  # --------------------------------------------------------------------------
  
  comparisons:
    
    chmod_vs_hsed:
      
      context: "When to use file permissions vs crypto permissions"
      
      chmod_file_permissions:
        
        description: "Traditional Unix file permissions (rwx)"
        
        strengths:
          - "Simpler: Only 3 bits (r, w, x)"
          - "Mature: 50+ years of production use"
          - "Universal: Every Unix system uses same model"
          - "Well understood: Every developer knows chmod"
          - "Tooling: ls, chmod, chown built into OS"
        
        weaknesses:
          - "Limited scope: Only controls file access"
          - "No crypto semantics: Doesn't distinguish sign vs encrypt"
          - "Binary only: Either have permission or don't"
          - "No key management: Doesn't handle cryptographic keys"
        
        best_for:
          - "Controlling access to files and directories"
          - "Standard Unix/Linux security model"
          - "When cryptographic operations aren't involved"
        
        real_world_example: |
          Web server configuration:
          ```bash
          chmod 644 /etc/nginx/nginx.conf
          # Admin can edit (rw-)
          # Nginx can read (r--)
          # Simple, sufficient, proven
          ```
      
      hsed_crypto_permissions:
        
        description: "HSED cryptographic operation permissions"
        
        strengths:
          - "Crypto semantics: Distinguishes hash, sign, encrypt, decrypt"
          - "Separation of duties: Sign separate from encrypt"
          - "Cloud native: Maps to KMS/HSM systems"
          - "Composable: Permissions combine predictably"
          - "Auditable: Clear permission → operation mapping"
        
        weaknesses:
          - "More complex: 4 bits instead of 3"
          - "Newer: Not 50 years of history"
          - "Requires translation: Must map to provider IAM"
          - "Learning curve: New model to learn"
        
        best_for:
          - "Controlling access to cryptographic operations"
          - "KMS/HSM permission modeling"
          - "Multi-cloud security architectures"
          - "When separation of crypto duties is critical"
        
        real_world_example: |
          CI/CD signing service:
          ```yaml
          role: hsed:signer (12)
          # Can verify signatures (H)
          # Can create signatures (S)
          # Cannot decrypt secrets (no D)
          # Cannot encrypt data (no E)
          # Impossible to express with chmod alone
          ```
      
      decision_framework:
        
        key_factors:
          - "Nature of resource: Files use chmod, crypto keys use HSED"
          - "Operation types: File I/O use chmod, crypto ops use HSED"
          - "Compliance needs: Crypto compliance often requires HSED-level granularity"
        
        decision_tree: |
          If controlling access to files/directories:
            → Use chmod (standard Unix model)
          
          If controlling cryptographic operations:
            → Use HSED (crypto-specific model)
          
          If both (e.g., key files on disk):
            → Use both (chmod for file access, HSED for key operations)
          
          Default for new crypto systems:
            → Start with HSED, map to provider IAM
        
        common_selection_mistakes:
          - "Using chmod alone for key files: Doesn't control what operations can be performed with keys"
          - "Assuming file permissions control crypto operations: They don't, need HSED layer"
          - "Mixing metaphors: Don't say 'chmod 755 the KMS key' - use HSED terminology"
      
      recommended_default: |
        Use chmod and HSED together:
        
        **Example: Private key file**
        ```bash
        # File level: chmod controls who can access file
        chmod 600 /etc/ssl/private/signing-key.pem
        # Only owner can read/write the file
        
        # Operation level: HSED controls what operations allowed
        hsed:signer (12)
        # Can use key to verify and sign
        # Cannot use key to decrypt or encrypt
        ```
        
        chmod controls the file, HSED controls the operations. Both layers needed 
        for complete security.
  
  # --------------------------------------------------------------------------
  # Key Takeaways
  # --------------------------------------------------------------------------
  
  key_takeaways:
    
    critical_concepts:
      - "chmod succeeded because of simplicity: 3 operations (rwx), octal notation (0-7), clear semantics. HSED applies same principles with 4 operations (HSED), octal notation (0-15)."
      - "The analogy is structural, not superficial: Both models use bit operations, octal composition, and clear permission semantics. If you understand chmod 755, you understand hsed 12."
      - "Four bits needed, not three: Crypto requires separating sign (attestation) from encrypt (confidentiality). Three bits would conflate these, enabling security violations."
      - "Common mappings: chmod 755 → hsed:signer (12), chmod 600 → hsed:vault (3), chmod 644 → hsed:audit (9). File patterns translate to crypto patterns."
    
    actionable_steps:
      - "Practice mental translation: Next time you write chmod 755, ask 'what would be the HSED equivalent?' Build intuition through repetition."
      - "Start with familiar patterns: If you know chmod 644 is 'readable file', remember hsed 9 is 'auditable crypto' (similar read-focus pattern)."
      - "Use bit arithmetic: Just like rwx = 4+2+1 = 7, practice HSED = 8+4+2+1 = 15. Mental math builds fluency."
    
    common_pitfalls_summary:
      - "Don't treat HSED as separate from chmod - it's an evolution of the same permission model for a new domain"
      - "Don't try to use only 3 bits for crypto - the fourth bit (separating S and E) is critical for security"
      - "Don't forget the structural analogy when explaining to others - 'like chmod for crypto' is the fastest way to transfer knowledge"
    
    remember_this:
      - "If chmod is 'rwx', HSED is 'HSED' - same principles, new operations"
      - "chmod 755 is to file execution as hsed 12 is to code signing"
      - "The best security models are obvious in retrospect - HSED should feel as natural as chmod"
    
    next_steps:
      - "Section 1.03 defines each permission bit in detail: Hash, Sign, Encrypt, Decrypt"
      - "Section 1.04 covers octal notation and permission composition mechanics"
      - "Section 1.05 introduces standard roles: hsed:root, hsed:signer, hsed:vault, hsed:audit"

---
