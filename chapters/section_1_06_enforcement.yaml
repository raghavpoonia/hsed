---
document_info:
  chapter: "1"
  section: "06"
  title: "Permission Enforcement Principles"
  version: "1.0.0"
  author: "Raghav Dinesh"
  github: "github.com/raghavpoonia"
  license: "MIT"
  created: "2025-12-29"
  estimated_pages: 6
  tags: ["hsed", "enforcement", "runtime-checking", "audit-logging", "fail-closed"]

# ============================================================================
# SECTION 1.06: PERMISSION ENFORCEMENT PRINCIPLES
# ============================================================================

section_1_06_enforcement:
  
  # --------------------------------------------------------------------------
  # Overview and Context
  # --------------------------------------------------------------------------
  
  overview: |
    You know the permission bits (H, S, E, D), how to combine them (octal 
    notation), and which roles to use (signer, vault, audit, etc.). Now comes 
    the critical question: How do you enforce these permissions?
    
    Permission models are only as good as their enforcement. A perfect HSED 
    design means nothing if services can bypass permission checks. This section 
    covers the "how" of HSED enforcement:
    
    1. **Runtime enforcement**: Checking permissions before every operation
    2. **Policy validation**: Preventing bad policies from being deployed
    3. **Audit logging**: Recording all cryptographic operations
    4. **Fail-closed patterns**: Denying access when checks fail
    5. **Enforcement points**: Where to implement permission checks
    
    By the end, you'll understand how to build HSED systems that can't be 
    bypassed, that fail safely, and that provide complete audit trails.
  
  # --------------------------------------------------------------------------
  # Core Concepts
  # --------------------------------------------------------------------------
  
  core_concepts:
    
    runtime_enforcement:
      
      definition: |
        Runtime enforcement means checking permissions at the moment an operation 
        is requested, before allowing it to proceed. Every cryptographic operation 
        must pass a permission check first.
        
        **Core principle:** Trust nothing, verify everything.
        
        **Enforcement pattern:**
        ```python
        def cryptographic_operation(principal, operation, key_id, data):
            # 1. Get principal's permissions
            permissions = get_permissions(principal, key_id)
            
            # 2. Check if operation is allowed
            if not has_permission(permissions, operation):
                audit_log(principal, operation, key_id, "DENIED")
                raise PermissionDeniedError()
            
            # 3. Perform operation
            result = perform_operation(operation, key_id, data)
            
            # 4. Audit success
            audit_log(principal, operation, key_id, "SUCCESS")
            
            return result
        ```
      
      why_it_matters: |
        Without runtime enforcement:
        
        1. **Permissions become advisory**: Services can ignore them
        2. **Audit trails are incomplete**: Operations happen without logging
        3. **Least privilege fails**: Over-permissive access isn't caught
        4. **Compliance violations**: Can't prove access controls work
        
        Runtime enforcement is the difference between "we have a permission 
        model" and "our permission model actually protects resources."
      
      key_components:
        
        permission_retrieval:
          what: "Get principal's current permissions for requested resource"
          source: "IAM system, policy store, or KMS policy"
          caching: "Can cache for 5 minutes max, must respect revocations"
          example: |
            permissions = policy_store.get(
                principal="ci-cd-service",
                resource="production-signing-key"
            )
            # Returns: 12 (hsed:signer)
        
        permission_checking:
          what: "Verify operation is allowed by permission bits"
          method: "Bitwise AND operation"
          fail_mode: "Deny if permission not granted"
          example: |
            operation = SIGN  # Value: 4
            permissions = 12  # hsed:signer (H+S)
            
            allowed = (permissions & operation) != 0
            # 12 & 4 = 4 != 0 → True, allowed
        
        operation_execution:
          what: "Perform cryptographic operation if permitted"
          isolation: "Operation executes in protected context (HSM/KMS)"
          error_handling: "Distinguish permission errors from operational errors"
          example: |
            try:
                signature = hsm.sign(key_id, data)
                return signature
            except PermissionDeniedError:
                # Permission problem - audit and deny
                raise
            except OperationalError:
                # HSM/KMS problem - different handling
                raise
        
        audit_logging:
          what: "Record operation attempt and outcome"
          timing: "Log before and after operation"
          content: "Principal, operation, resource, timestamp, outcome"
          example: |
            audit_log.write({
                "timestamp": "2025-12-29T01:05:00Z",
                "principal": "ci-cd-service",
                "operation": "sign",
                "resource": "production-signing-key",
                "outcome": "success",
                "permissions": 12
            })
      
      how_it_works: |
        **End-to-end enforcement flow:**
        
        1. **Request arrives**
           - Service: "CI/CD"
           - Operation: "Sign release artifact"
           - Key: "production-signing-key"
        
        2. **Permission retrieval**
           - Query: What permissions does CI/CD have for production-signing-key?
           - Response: 12 (hsed:signer = H+S)
        
        3. **Permission check**
           - Required: Sign permission (bit 2 = 4)
           - Granted: 12 (binary: 1100)
           - Check: 12 & 4 = 4 != 0 → Allowed ✓
        
        4. **Pre-operation audit**
           - Log: "CI/CD attempting sign on production-signing-key"
        
        5. **Operation execution**
           - HSM/KMS performs signing
           - Returns signature
        
        6. **Post-operation audit**
           - Log: "CI/CD successfully signed with production-signing-key"
        
        7. **Return result**
           - Signature returned to CI/CD
        
        **If permission denied:**
        - Step 3 fails: 12 & 1 = 0 (no Decrypt permission)
        - Audit: "CI/CD DENIED decrypt on production-signing-key"
        - Exception raised, no operation performed
      
      real_world_example: |
        **KMS service with runtime enforcement:**
        
        ```python
        class SecureKMS:
            def __init__(self, hsm, policy_store, audit_log):
                self.hsm = hsm
                self.policies = policy_store
                self.audit = audit_log
            
            def sign(self, principal: str, key_id: str, data: bytes) -> bytes:
                """Sign data with runtime permission enforcement"""
                
                # 1. Get permissions
                try:
                    permissions = self.policies.get_permissions(
                        principal=principal,
                        resource=key_id
                    )
                except PolicyNotFoundError:
                    # No policy = no permissions = deny
                    self._audit_denied(principal, "sign", key_id, "no_policy")
                    raise PermissionDeniedError(
                        f"No policy found for {principal} on {key_id}"
                    )
                
                # 2. Check Sign permission (bit 2 = 4)
                if not (permissions & 4):
                    self._audit_denied(principal, "sign", key_id, "insufficient_perms")
                    raise PermissionDeniedError(
                        f"{principal} lacks Sign permission for {key_id}. "
                        f"Has: {permissions}, Needs: Sign (4)"
                    )
                
                # 3. Pre-operation audit
                request_id = self._audit_attempt(principal, "sign", key_id, permissions)
                
                # 4. Perform operation
                try:
                    signature = self.hsm.sign(key_id, data)
                except HSMError as e:
                    self._audit_failed(request_id, str(e))
                    raise OperationalError(f"HSM signing failed: {e}")
                
                # 5. Post-operation audit
                self._audit_success(request_id, len(signature))
                
                return signature
            
            def decrypt(self, principal: str, key_id: str, ciphertext: bytes) -> bytes:
                """Decrypt data with runtime permission enforcement"""
                
                # 1. Get permissions
                permissions = self.policies.get_permissions(principal, key_id)
                
                # 2. Check Decrypt permission (bit 0 = 1)
                if not (permissions & 1):
                    self._audit_denied(principal, "decrypt", key_id, "insufficient_perms")
                    raise PermissionDeniedError(
                        f"{principal} lacks Decrypt permission for {key_id}. "
                        f"Has: {permissions}, Needs: Decrypt (1)"
                    )
                
                # 3. Additional decrypt checks (high sensitivity)
                if not self._validate_decrypt_context(principal, key_id):
                    self._audit_denied(principal, "decrypt", key_id, "context_violation")
                    raise PermissionDeniedError("Decrypt context validation failed")
                
                # 4. Pre-operation audit (decrypt is sensitive)
                request_id = self._audit_attempt(
                    principal, "decrypt", key_id, permissions,
                    sensitivity="high"
                )
                
                # 5. Perform operation
                plaintext = self.hsm.decrypt(key_id, ciphertext)
                
                # 6. Post-operation audit
                self._audit_success(request_id, len(plaintext))
                
                # 7. Alert on sensitive decrypts
                if self._is_sensitive_key(key_id):
                    self._alert_security_team(
                        f"{principal} decrypted sensitive key {key_id}"
                    )
                
                return plaintext
        ```
        
        **What this enforces:**
        - ✓ Every operation checks permissions
        - ✓ No bypass possible (HSM access requires going through enforcement)
        - ✓ Complete audit trail
        - ✓ Fail-closed (deny if policy missing or permissions insufficient)
        - ✓ Additional checks for sensitive operations (decrypt)
      
      related_concepts:
        - "Defense in depth: Multiple enforcement layers"
        - "Fail-closed: Deny by default, allow only when explicitly permitted"
        - "Audit trail: Complete record of access attempts"
    
    policy_validation:
      
      definition: |
        Policy validation means checking policies BEFORE they're deployed to 
        production. Catch mistakes in development, not in production incidents.
        
        **Validation checks:**
        1. **Syntax validation**: Policy is well-formed YAML/JSON
        2. **Semantic validation**: Permissions are valid HSED values (0-15)
        3. **Security validation**: No anti-patterns or over-permissions
        4. **Consistency validation**: No conflicting policies
        5. **Compliance validation**: Meets regulatory requirements
      
      why_it_matters: |
        Prevention is cheaper than detection:
        
        **Without validation:**
        - Typos deploy to production ("hsed:singr" instead of "hsed:signer")
        - Over-permissive policies go unnoticed (accidentally grant root)
        - Anti-patterns become standard (everyone copies the bad example)
        - Compliance violations discovered during audit (expensive)
        
        **With validation:**
        - Errors caught in CI/CD (before production)
        - Anti-patterns rejected automatically
        - Best practices enforced consistently
        - Compliance by design, not by accident
      
      key_components:
        
        syntax_validation:
          what: "Check policy file is valid YAML/JSON"
          tools: ["yamllint", "jsonlint", "custom parsers"]
          catches: "Typos, malformed files, missing fields"
          example: |
            # Invalid YAML (caught by syntax validation)
            policy:
              role: hsed:signer
              permissions 12  # Missing colon
        
        semantic_validation:
          what: "Check policy values are valid HSED"
          rules:
            - "Permissions must be 0-15"
            - "Role names must match standard roles or be custom"
            - "Key IDs must exist"
            - "Principals must be valid identities"
          example: |
            # Invalid semantics (caught by semantic validation)
            policy:
              role: hsed:custom
              permissions: 20  # Invalid: max is 15
        
        security_validation:
          what: "Check for security anti-patterns"
          anti_patterns:
            - "permissions: 15 for non-break-glass"
            - "permissions: 13 (S+D) without justification"
            - "wildcard principals (*)"
            - "wildcard resources (*)"
          example: |
            # Security anti-pattern (caught by security validation)
            policy:
              principal: "*"  # Wildcard - dangerous
              permissions: 15  # Root - dangerous
              # Rejected: Can't grant root to everyone
        
        consistency_validation:
          what: "Check policies don't conflict"
          checks:
            - "No duplicate principal+resource combinations"
            - "Inherited permissions don't contradict"
            - "Group memberships resolve correctly"
          example: |
            # Conflicting policies (caught by consistency validation)
            policy_1:
              principal: "ci-cd"
              resource: "signing-key"
              permissions: 12
            
            policy_2:
              principal: "ci-cd"
              resource: "signing-key"
              permissions: 3
            
            # Conflict: Which permissions apply?
        
        compliance_validation:
          what: "Check regulatory requirements met"
          requirements:
            soc2: "Separation of duties enforced"
            pci_dss: "Decrypt permission restricted"
            hipaa: "Audit logging enabled"
            gdpr: "Data access tracked"
          example: |
            # Compliance violation (caught by compliance validation)
            policy:
              principal: "admin"
              permissions: 13  # H+S+D
            
            # Rejected: Violates SOC2 separation of duties
            # (Sign + Decrypt in same role)
      
      how_it_works: |
        **CI/CD validation pipeline:**
        
        ```yaml
        # .github/workflows/validate-policies.yml
        name: Validate HSED Policies
        
        on:
          pull_request:
            paths:
              - 'policies/**/*.yaml'
        
        jobs:
          validate:
            runs-on: ubuntu-latest
            steps:
              - uses: actions/checkout@v3
              
              - name: Syntax validation
                run: |
                  yamllint policies/
              
              - name: HSED semantic validation
                run: |
                  hsed validate --strict policies/
              
              - name: Security validation
                run: |
                  hsed audit --check-anti-patterns policies/
              
              - name: Compliance validation
                run: |
                  hsed compliance --soc2 --pci-dss policies/
              
              - name: Generate report
                run: |
                  hsed report --output policy-validation.html
              
              - name: Block on violations
                run: |
                  if hsed has-violations; then
                    echo "Policy validation failed"
                    exit 1
                  fi
        ```
        
        **Validation stages:**
        1. Developer commits policy change
        2. CI/CD runs validation automatically
        3. Syntax errors → immediate failure
        4. Semantic errors → clear error messages
        5. Security anti-patterns → policy rejected
        6. Compliance violations → policy rejected
        7. All checks pass → policy approved for deployment
      
      real_world_example: |
        **Policy validator implementation:**
        
        ```python
        class HSEDPolicyValidator:
            def validate_policy(self, policy: dict) -> ValidationResult:
                errors = []
                warnings = []
                
                # Syntax validation
                if not self._validate_syntax(policy):
                    errors.append("Invalid YAML syntax")
                    return ValidationResult(errors=errors)
                
                # Semantic validation
                perms = policy.get("permissions")
                if perms is None:
                    errors.append("Missing 'permissions' field")
                elif not (0 <= perms <= 15):
                    errors.append(f"Invalid permissions: {perms} (must be 0-15)")
                
                # Security validation
                if perms == 15 and "break-glass" not in policy.get("tags", []):
                    errors.append(
                        "Root permission (15) requires 'break-glass' tag"
                    )
                
                if perms == 13:  # H+S+D - dangerous
                    if "justification" not in policy:
                        errors.append(
                            "Permission 13 (H+S+D) requires justification"
                        )
                    warnings.append(
                        "Permission 13 combines Sign and Decrypt - "
                        "consider separating"
                    )
                
                if policy.get("principal") == "*":
                    errors.append("Wildcard principal not allowed")
                
                # Compliance validation (SOC2)
                if perms in [7, 13, 15]:  # Combinations that violate separation
                    if not policy.get("approved_by_security_team"):
                        errors.append(
                            f"Permission {perms} violates SOC2 separation of duties. "
                            "Requires security team approval."
                        )
                
                # Consistency validation
                conflicts = self._check_conflicts(policy)
                if conflicts:
                    errors.extend(conflicts)
                
                return ValidationResult(
                    valid=len(errors) == 0,
                    errors=errors,
                    warnings=warnings
                )
        ```
        
        **Example validation failures:**
        
        ```yaml
        # Failure 1: Invalid permission value
        policy:
          permissions: 20  # ✗ Invalid (max is 15)
        
        # Failure 2: Root without break-glass tag
        policy:
          permissions: 15  # ✗ Root requires break-glass tag
          tags: []
        
        # Failure 3: Dangerous combination without justification
        policy:
          permissions: 13  # ✗ H+S+D requires justification
        
        # Failure 4: Wildcard principal
        policy:
          principal: "*"  # ✗ Wildcards not allowed
          permissions: 12
        
        # Success: Valid policy
        policy:
          principal: "ci-cd-service"
          resource: "signing-key"
          permissions: 12  # ✓ Valid hsed:signer
          tags: ["production", "ci-cd"]
        ```
      
      related_concepts:
        - "Shift-left security: Catch problems early in development"
        - "Policy as code: Version-controlled, validated, auditable"
        - "CI/CD integration: Automated validation before deployment"
    
    audit_logging:
      
      definition: |
        Audit logging records every cryptographic operation attempt: who tried 
        to do what, when, with which permissions, and what the outcome was.
        
        **Required audit fields:**
        - Timestamp (microsecond precision)
        - Principal (who)
        - Operation (what)
        - Resource (which key/resource)
        - Permissions granted
        - Outcome (success/denied/failed)
        - Request ID (for correlation)
        - Context (IP, user agent, etc.)
      
      why_it_matters: |
        Audit logs enable:
        
        1. **Security monitoring**: Detect anomalies in real-time
        2. **Incident response**: Investigate what happened
        3. **Compliance**: Prove controls work (SOC2, PCI-DSS, HIPAA)
        4. **Forensics**: Reconstruct attack timeline
        5. **Optimization**: Identify over-permissive policies
        
        Without comprehensive audit logs:
        - Can't prove access controls work (compliance failure)
        - Can't detect breaches in progress (security failure)
        - Can't investigate incidents (operational failure)
        - Can't optimize permissions (efficiency failure)
      
      key_components:
        
        structured_logging:
          format: "JSON for machine-readability"
          required_fields:
            - "timestamp (ISO 8601)"
            - "principal (string)"
            - "operation (enum: hash, sign, encrypt, decrypt)"
            - "resource (string)"
            - "permissions (0-15)"
            - "outcome (enum: success, denied, failed)"
            - "request_id (UUID)"
          optional_fields:
            - "ip_address"
            - "user_agent"
            - "duration_ms"
            - "error_message"
          example: |
            {
              "timestamp": "2025-12-29T01:05:00.123456Z",
              "principal": "ci-cd-service",
              "operation": "sign",
              "resource": "production-signing-key",
              "permissions": 12,
              "outcome": "success",
              "request_id": "550e8400-e29b-41d4-a716-446655440000",
              "ip_address": "10.0.1.42",
              "duration_ms": 23
            }
        
        log_levels:
          debug: "Detailed operation information"
          info: "Successful operations"
          warn: "Unusual but not necessarily bad"
          error: "Failed operations"
          critical: "Permission denials, security events"
          example: |
            INFO: Successful sign operation
            ERROR: HSM communication failed
            CRITICAL: Permission denied - ci-cd attempted decrypt
        
        tamper_resistance:
          method: "Sign log entries with separate key"
          verification: "Logs can be verified later"
          storage: "Write-once storage (S3 Object Lock, immutable logs)"
          example: |
            log_entry = {
              "timestamp": "2025-12-29T01:05:00Z",
              "data": {...}
            }
            signature = sign(json.dumps(log_entry), audit-key)
            log_entry["signature"] = signature
            # Tampering detectable via signature verification
        
        real_time_monitoring:
          stream: "Send logs to SIEM (Splunk, ELK, Datadog)"
          alerts: "Trigger on critical events"
          dashboards: "Visualize permission usage"
          example: |
            # Alert on permission denial
            if log.outcome == "denied":
                alert_security_team(log)
            
            # Alert on sensitive decrypt
            if log.operation == "decrypt" and is_sensitive(log.resource):
                alert_security_team(log)
      
      how_it_works: |
        **Audit logging lifecycle:**
        
        1. **Pre-operation log**
           - Before permission check
           - Records attempt
           - Creates request ID
        
        2. **Permission check**
           - Check if allowed
           - If denied: Log denial, raise exception
           - If allowed: Continue
        
        3. **Operation execution**
           - Perform cryptographic operation
           - If fails: Log failure
           - If succeeds: Continue
        
        4. **Post-operation log**
           - After successful operation
           - Records completion
           - Includes duration, result size
        
        5. **Log shipping**
           - Send to SIEM
           - Store in immutable storage
           - Verify signature
        
        6. **Monitoring**
           - Real-time anomaly detection
           - Alert on critical events
           - Dashboard updates
      
      real_world_example: |
        **Comprehensive audit logging:**
        
        ```python
        class AuditLogger:
            def __init__(self, siem_client, storage_client):
                self.siem = siem_client
                self.storage = storage_client
                self.audit_key = load_audit_signing_key()
            
            def log_attempt(
                self,
                principal: str,
                operation: str,
                resource: str,
                permissions: int
            ) -> str:
                """Log operation attempt"""
                request_id = str(uuid.uuid4())
                
                log_entry = {
                    "timestamp": datetime.utcnow().isoformat(),
                    "request_id": request_id,
                    "principal": principal,
                    "operation": operation,
                    "resource": resource,
                    "permissions": permissions,
                    "stage": "attempt",
                    "ip_address": get_client_ip(),
                    "user_agent": get_user_agent()
                }
                
                self._write_log(log_entry)
                return request_id
            
            def log_denied(
                self,
                request_id: str,
                reason: str
            ):
                """Log permission denial"""
                log_entry = {
                    "timestamp": datetime.utcnow().isoformat(),
                    "request_id": request_id,
                    "outcome": "denied",
                    "reason": reason,
                    "severity": "critical"
                }
                
                self._write_log(log_entry)
                
                # Real-time alert on denial
                self.siem.alert({
                    "type": "permission_denied",
                    "request_id": request_id,
                    "reason": reason
                })
            
            def log_success(
                self,
                request_id: str,
                duration_ms: int,
                result_size: int
            ):
                """Log successful operation"""
                log_entry = {
                    "timestamp": datetime.utcnow().isoformat(),
                    "request_id": request_id,
                    "outcome": "success",
                    "duration_ms": duration_ms,
                    "result_size": result_size,
                    "severity": "info"
                }
                
                self._write_log(log_entry)
            
            def _write_log(self, log_entry: dict):
                """Write log with tamper resistance"""
                
                # Sign log entry
                log_json = json.dumps(log_entry, sort_keys=True)
                signature = sign(log_json, self.audit_key)
                log_entry["signature"] = signature
                
                # Write to immutable storage
                self.storage.append(
                    bucket="audit-logs",
                    key=f"logs/{log_entry['timestamp'][:10]}/{log_entry['request_id']}.json",
                    data=json.dumps(log_entry)
                )
                
                # Stream to SIEM
                self.siem.send(log_entry)
                
                # Alert on critical events
                if log_entry.get("severity") == "critical":
                    self.siem.alert(log_entry)
        ```
        
        **Usage in KMS:**
        
        ```python
        def sign(self, principal, key_id, data):
            # 1. Log attempt
            request_id = audit_logger.log_attempt(
                principal, "sign", key_id, permissions
            )
            
            # 2. Check permissions
            if not (permissions & 4):
                # 3a. Log denial
                audit_logger.log_denied(request_id, "missing_sign_permission")
                raise PermissionDeniedError()
            
            # 4. Perform operation
            start = time.time()
            signature = hsm.sign(key_id, data)
            duration = int((time.time() - start) * 1000)
            
            # 5. Log success
            audit_logger.log_success(request_id, duration, len(signature))
            
            return signature
        ```
      
      related_concepts:
        - "SIEM integration: Security Information and Event Management"
        - "Tamper-evident logs: Cryptographic integrity protection"
        - "Real-time monitoring: Detect anomalies as they happen"
    
    fail_closed_patterns:
      
      definition: |
        Fail-closed means denying access when permission checks fail or are 
        ambiguous. The opposite is fail-open (allow when checks fail).
        
        **Principle:** Better to deny legitimate access temporarily than allow 
        unauthorized access permanently.
        
        **Fail-closed scenarios:**
        - Policy not found → Deny
        - Policy ambiguous → Deny
        - Permission check error → Deny
        - Audit logging failed → Deny (can't prove what happened)
        - HSM/KMS unavailable → Deny (can't verify permissions)
      
      why_it_matters: |
        Security vs availability tradeoff:
        
        **Fail-open (dangerous):**
        - Permission check fails → Allow anyway
        - Consequence: Unauthorized access during outages
        - Example: "Can't reach policy server, allow operation"
        
        **Fail-closed (secure):**
        - Permission check fails → Deny
        - Consequence: Service disruption during outages
        - Example: "Can't reach policy server, deny operation"
        
        For cryptographic operations, security must win. A few minutes of 
        downtime during outages is acceptable. Unauthorized decrypt of production 
        secrets is not.
      
      key_components:
        
        explicit_deny_by_default:
          pattern: "Whitelist (explicit allow), not blacklist"
          implementation: "Return false unless permission explicitly granted"
          example: |
            def has_permission(permissions, required):
                # Explicit check - returns False if not granted
                return (permissions & required) != 0
                # NOT: return (permissions & required) != required
        
        error_handling:
          pattern: "Errors become denials"
          rationale: "Can't prove permission, so deny"
          example: |
            try:
                permissions = policy_store.get(principal, resource)
            except PolicyStoreError:
                # Can't get permissions → Deny
                audit_log("permission_check_failed", "deny")
                raise PermissionDeniedError("Policy store unavailable")
        
        timeout_handling:
          pattern: "Timeouts become denials"
          timeout_limits: "Permission checks: 1s max, Operations: 30s max"
          example: |
            try:
                permissions = policy_store.get(principal, resource, timeout=1.0)
            except TimeoutError:
                # Slow response → Deny
                audit_log("permission_check_timeout", "deny")
                raise PermissionDeniedError("Permission check timeout")
        
        ambiguity_handling:
          pattern: "Ambiguous policies become denials"
          ambiguity_types:
            - "Conflicting policies"
            - "Circular dependencies"
            - "Unresolved variables"
          example: |
            if has_conflicting_policies(principal, resource):
                # Conflict → Deny
                audit_log("policy_conflict", "deny")
                raise PermissionDeniedError("Conflicting policies")
      
      how_it_works: |
        **Fail-closed enforcement:**
        
        ```python
        def enforce_hsed_permission(
            principal: str,
            operation: str,
            resource: str
        ) -> bool:
            """
            Enforce HSED permission with fail-closed pattern.
            
            Returns True only if permission explicitly granted.
            All errors, timeouts, or ambiguities result in False.
            """
            
            try:
                # 1. Get permissions (with timeout)
                permissions = policy_store.get(
                    principal=principal,
                    resource=resource,
                    timeout=1.0  # Fail fast
                )
                
                # 2. Check for conflicts
                if policy_store.has_conflicts(principal, resource):
                    audit_log(principal, operation, resource, "conflict", "deny")
                    return False
                
                # 3. Verify operation is valid
                operation_bit = get_operation_bit(operation)
                if operation_bit is None:
                    audit_log(principal, operation, resource, "invalid_op", "deny")
                    return False
                
                # 4. Check permission bit
                allowed = (permissions & operation_bit) != 0
                
                if not allowed:
                    audit_log(principal, operation, resource, "insufficient", "deny")
                
                return allowed
                
            except PolicyStoreError as e:
                # Policy store error → Deny
                audit_log(principal, operation, resource, f"error:{e}", "deny")
                return False
                
            except TimeoutError:
                # Timeout → Deny
                audit_log(principal, operation, resource, "timeout", "deny")
                return False
                
            except Exception as e:
                # Any other error → Deny
                audit_log(principal, operation, resource, f"exception:{e}", "deny")
                return False
        ```
        
        **Key properties:**
        - Returns True ONLY if permission explicitly granted
        - All error paths return False (deny)
        - Audit logs capture all denials with reasons
        - No way to accidentally allow when check fails
      
      real_world_example: |
        **Production incident demonstrating fail-closed:**
        
        **Scenario:** Policy store becomes unavailable (network partition)
        
        **Fail-open behavior (bad):**
        ```python
        try:
            permissions = policy_store.get(principal, resource)
        except PolicyStoreError:
            # DANGEROUS: Allow when policy store down
            logger.warn("Policy store down, allowing operation")
            return True  # ✗ Security failure
        
        # Result during outage:
        # - All operations allowed (no permission checks)
        # - Attacker can decrypt secrets
        # - Compliance violation (no access control)
        ```
        
        **Fail-closed behavior (good):**
        ```python
        try:
            permissions = policy_store.get(principal, resource, timeout=1.0)
        except PolicyStoreError:
            # SECURE: Deny when policy store down
            audit_log(principal, operation, resource, "policy_store_down", "deny")
            raise PermissionDeniedError("Policy store unavailable")
        
        # Result during outage:
        # - All operations denied (fail-secure)
        # - Attacker cannot exploit outage
        # - Service degraded but secure
        # - Alert fires, incident response begins
        # - Policy store restored, service resumes
        ```
        
        **Outage timeline:**
        - T+0min: Policy store network partition
        - T+0min: All crypto operations start failing (fail-closed)
        - T+1min: Monitoring detects high error rate
        - T+2min: Incident declared, on-call paged
        - T+5min: Network partition identified
        - T+10min: Network restored
        - T+10min: Crypto operations resume normally
        
        **Total impact:**
        - 10 minutes of service disruption
        - Zero unauthorized access
        - Complete audit trail maintained
        
        This is the correct tradeoff for cryptographic systems.
      
      related_concepts:
        - "Defense in depth: Multiple fail-closed checks"
        - "Secure by default: Deny unless explicitly allowed"
        - "Circuit breakers: Fail fast and recover quickly"
  
  # --------------------------------------------------------------------------
  # Key Takeaways
  # --------------------------------------------------------------------------
  
  key_takeaways:
    
    critical_concepts:
      - "Runtime enforcement: Check permissions before EVERY operation using bitwise AND. No bypasses allowed."
      - "Policy validation: Catch errors in CI/CD before production. Syntax, semantics, security, compliance - all validated automatically."
      - "Audit logging: Record every operation attempt with timestamp, principal, operation, outcome. Tamper-evident, real-time monitored."
      - "Fail-closed: Deny when checks fail, timeout, or error. Security over availability for cryptographic operations."
    
    actionable_steps:
      - "Implement permission checks at every KMS/HSM entry point. No operation without explicit permission verification."
      - "Add policy validation to CI/CD pipeline today. Block deployment of invalid policies automatically."
      - "Set up audit log monitoring: Alert on permission denials, sensitive decrypts, unusual patterns. Review daily."
    
    common_pitfalls_summary:
      - "Don't skip runtime checks 'for performance' - permission checks take microseconds, breaches cost millions"
      - "Don't fail-open 'for availability' - 10 minutes downtime beats one unauthorized decrypt"
      - "Don't log after operation only - log attempts and denials too, that's where attacks show up"
    
    remember_this:
      - "Enforce at runtime, validate at deploy-time, audit at all times"
      - "Fail-closed: Deny when uncertain, better safe than breached"
      - "Complete audit trails are non-negotiable for compliance and security"
    
    next_steps:
      - "Section 1.07 covers security principles: Least privilege and separation of duties with HSED"
      - "Section 1.08 explores role hierarchies and permission inheritance patterns"
      - "Section 1.09 applies everything to real-world scenarios with step-by-step implementations"

---
