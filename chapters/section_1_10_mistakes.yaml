# section_1_10_mistakes.yaml
---
document_info:
  chapter: "1"
  section: "10"
  title: "Common Mistakes and Anti-Patterns"
  version: "1.0.0"
  author: "Raghav Dinesh"
  github: "github.com/raghavpoonia"
  license: "MIT"
  created: "2025-12-29"
  estimated_pages: 5
  tags: ["hsed", "anti-patterns", "mistakes", "best-practices", "lessons-learned"]

# ============================================================================
# SECTION 1.10: COMMON MISTAKES AND ANTI-PATTERNS
# ============================================================================

section_1_10_mistakes:
  
  # --------------------------------------------------------------------------
  # Overview and Context
  # --------------------------------------------------------------------------
  
  overview: |
    You now understand HSED fundamentals: permission bits, standard roles, 
    security principles, and real-world scenarios. But knowing what to do isn't 
    enough - you also need to know what NOT to do.
    
    This section catalogs the five most common HSED mistakes we've seen in 
    production systems:
    
    1. **Granting root everywhere**: "hsed 15 just to be safe"
    2. **Combining incompatible permissions**: "hsed 13 for convenience"
    3. **Forgetting audit requirements**: No logging, no compliance
    4. **Permission sprawl**: Accumulating unused permissions
    5. **Copy-paste from Stack Overflow**: Unvalidated examples
    
    Each mistake includes:
    - What it looks like (how to recognize it)
    - Why people do this (the reasoning that leads here)
    - Consequences (what goes wrong)
    - How to avoid (prevention)
    - How to fix if stuck (remediation)
    
    Learn from others' mistakes. Don't repeat them.
  
  # --------------------------------------------------------------------------
  # Common Mistakes
  # --------------------------------------------------------------------------
  
  common_mistakes:
    
    mistake_1_granting_root_everywhere:
      
      name: "Granting hsed:root (15) to Regular Services"
      
      what_it_looks_like:
        - "CI/CD pipeline with permissions: 15"
        - "Secrets manager with permissions: 15"
        - "Multiple services with full crypto authority"
        - "'Just give it all permissions to avoid issues'"
      
      why_people_do_this: |
        **Common reasoning:**
        1. "Don't know which permissions needed, so grant all"
        2. "Getting permission errors, easier to grant everything"
        3. "Will restrict later" (never happens)
        4. "It's just development/staging" (becomes production)
        5. "Security team isn't involved yet"
        
        **Root cause:** Lack of understanding of least privilege or permission 
        requirements. Taking shortcut during development that persists.
      
      consequences:
        
        immediate:
          - "Every service has god-mode crypto access"
          - "No separation of duties"
          - "Least privilege completely violated"
        
        long_term:
          - "Single compromise = complete breach"
          - "Can't audit who can do what (everyone can do everything)"
          - "Compliance violations (SOC2, PCI-DSS, HIPAA)"
          - "Impossible to trace security incidents"
        
        real_cost: |
          **Incident example:**
          CI/CD with root permissions (15) compromised via dependency confusion 
          attack. Attacker had:
          - Sign access: Signed malicious releases ✗
          - Decrypt access: Decrypted production secrets ✗
          - Encrypt access: Encrypted and exfiltrated data ✗
          
          With proper permissions (12 = signer), attacker would only have 
          sign access. Secrets and data would be safe.
          
          **Cost:** $2.3M breach response, 6 months remediation, customer trust lost.
      
      how_to_avoid: |
        **Prevention:**
        
        1. **Start with 0, add what's needed**
           ```yaml
           # Wrong: Start with root
           service:
             permissions: 15  # ✗
           
           # Right: Start with nothing
           service:
             permissions: 0  # Start here
             # Add H if needs verify: +8
             # Add S if needs sign: +4
             # Final: 12 (signer)
           ```
        
        2. **Map requirements to operations**
           - What does service actually do?
           - Which crypto operations needed?
           - Document justification for each permission
        
        3. **Policy validation in CI/CD**
           ```bash
           # Reject root for non-break-glass
           hsed validate --reject-root-for-services policies/
           ```
        
        4. **Security team review**
           - Root grants require security approval
           - Break-glass only, time-limited
           - MFA + approval + justification required
      
      how_to_fix_if_already_stuck: |
        **Remediation steps:**
        
        1. **Audit current permissions (Week 1)**
           ```bash
           # Find all services with root
           hsed audit find --permissions 15
           
           # Output: 47 services with root permissions
           ```
        
        2. **Analyze actual usage (Week 2)**
           ```bash
           # Check what permissions actually used
           hsed audit analyze-usage --last-30-days
           
           # Example output:
           # ci-cd: granted 15, used 12 (H+S only)
           # secrets: granted 15, used 3 (E+D only)
           ```
        
        3. **Create migration plan (Week 3)**
           - Group services by actual usage pattern
           - Assign appropriate HSED roles
           - Prioritize by risk (start with internet-facing)
        
        4. **Migrate gradually (Weeks 4-12)**
           - Week 4-5: Non-production environments
           - Week 6-8: Low-risk production services
           - Week 9-12: High-risk production services
        
        5. **Validate and monitor (Ongoing)**
           - Verify functionality after each migration
           - Monitor for permission errors
           - Adjust if needed (with justification)
        
        **Expected timeline:** 12 weeks for complete remediation
        
        **Success metrics:**
        - 0 services with root (except break-glass)
        - All services using appropriate roles
        - Complete audit trail of changes
      
      real_world_example: |
        **Before (broken):**
        ```yaml
        services:
          ci_cd:
            permissions: 15  # Root
          secrets_manager:
            permissions: 15  # Root
          api_gateway:
            permissions: 15  # Root
          database_service:
            permissions: 15  # Root
        
        # Every service has full crypto authority
        # Single compromise = complete breach
        ```
        
        **After (fixed):**
        ```yaml
        services:
          ci_cd:
            permissions: 12  # Signer (H+S)
            justification: "Sign releases after build"
          
          secrets_manager:
            permissions: 3  # Vault (E+D)
            justification: "Encrypt/decrypt application secrets"
          
          api_gateway:
            permissions: 10  # DMZ (H+E)
            justification: "Verify requests, encrypt at boundary"
          
          database_service:
            permissions: 0  # No crypto
            justification: "Store ciphertext only"
        
        # Each service has minimum necessary permissions
        # Defense in depth through permission separation
        ```
    
    mistake_2_combining_incompatible_permissions:
      
      name: "Combining Sign + Decrypt (hsed 13) for Convenience"
      
      what_it_looks_like:
        - "Service with permissions: 13 (H+S+D)"
        - "'Need both signing and secrets access'"
        - "Single service handling multiple responsibilities"
        - "No separation between attestation and confidentiality"
      
      why_people_do_this: |
        **Common reasoning:**
        1. "Service needs to sign AND access secrets"
        2. "Easier to have one service than split into two"
        3. "Don't see why sign + decrypt is problematic"
        4. "Works fine in development"
        5. "Will refactor later" (never happens)
        
        **Root cause:** Not understanding separation of duties principle. 
        Optimizing for development convenience over security.
      
      consequences:
        
        immediate:
          - "God-mode credential created"
          - "Violates separation of duties"
          - "Single service can forge AND access secrets"
        
        long_term:
          - "Compromise gives attacker complete capability"
          - "Can't audit attestation vs data access separately"
          - "Compliance violations (SOC2 control failures)"
          - "No independent verification of critical operations"
        
        real_cost: |
          **Incident example:**
          Payment processing service with permissions 13 (H+S+D):
          - Could decrypt payment details (D)
          - Could sign transaction approvals (S)
          - Could verify to evade detection (H)
          
          When compromised:
          - Attacker decrypted customer payment info
          - Attacker signed fraudulent transactions
          - Attacker verified signatures to look legitimate
          - No independent party could catch fraud
          
          **Cost:** $5.7M in fraudulent transactions, $2.1M PCI-DSS fines.
          
          With separation (signer=12, vault=3 as separate services), fraud 
          would require compromising BOTH services simultaneously.
      
      how_to_avoid: |
        **Prevention:**
        
        1. **Split responsibilities**
           ```yaml
           # Wrong: One service with both
           payment_processor:
             permissions: 13  # H+S+D ✗
           
           # Right: Split into focused services
           payment_decryptor:
             permissions: 9  # H+D (audit role)
             responsibility: "Decrypt payment data for processing"
           
           transaction_signer:
             permissions: 12  # H+S (signer role)
             responsibility: "Sign approved transactions"
           ```
        
        2. **Policy validation rejects 13**
           ```bash
           # CI/CD check
           hsed validate --reject-permission 13 policies/
           # Fails if any service has 13
           ```
        
        3. **Architecture review**
           - If service needs both sign and decrypt, question design
           - Usually indicates missing separation of duties
           - Refactor into multiple services
        
        4. **Exception process**
           - Permission 13 requires security team approval
           - Must document why separation impossible
           - Annual re-review of justification
      
      how_to_fix_if_already_stuck: |
        **Remediation:**
        
        1. **Identify services with 13**
           ```bash
           hsed audit find --permissions 13
           ```
        
        2. **Analyze data flow**
           - What does service decrypt?
           - What does service sign?
           - Are these truly coupled?
        
        3. **Design separation**
           - Service A: Decrypt only (permissions: 9 = H+D)
           - Service B: Sign only (permissions: 12 = H+S)
           - Communication: Service A → Service B via signed requests
        
        4. **Implement gradually**
           - Create new separated services
           - Migrate traffic incrementally
           - Decommission monolithic service
        
        5. **Example refactoring:**
           ```
           Before:
           payment_processor (13) → [decrypt, process, sign]
           
           After:
           payment_decryptor (9) → [decrypt, validate]
                 ↓
           fraud_detector (8) → [verify, analyze]
                 ↓
           transaction_signer (12) → [sign approval]
           
           Now requires compromising all three for fraud
           ```
      
      real_world_example: |
        **Anti-pattern:**
        ```python
        class PaymentProcessor:
            def __init__(self):
                self.permissions = 13  # H+S+D
            
            def process_payment(self, encrypted_payment):
                # Decrypt payment (D)
                payment = self.kms.decrypt(encrypted_payment)
                
                # Process payment
                result = self.process(payment)
                
                # Sign approval (S)
                signature = self.kms.sign(result)
                
                # Single service does everything
                return signed_result
        ```
        
        **Better pattern:**
        ```python
        class PaymentDecryptor:
            def __init__(self):
                self.permissions = 9  # H+D (audit)
            
            def decrypt_payment(self, encrypted_payment):
                return self.kms.decrypt(encrypted_payment)
        
        class TransactionSigner:
            def __init__(self):
                self.permissions = 12  # H+S (signer)
            
            def sign_approval(self, transaction):
                return self.kms.sign(transaction)
        
        # Orchestration requires both services
        # Compromise of one ≠ complete fraud capability
        ```
    
    mistake_3_forgetting_audit_requirements:
      
      name: "No Audit Logging or Incomplete Audit Trails"
      
      what_it_looks_like:
        - "Crypto operations with no logging"
        - "Logs missing critical fields (who, what, when)"
        - "No monitoring or alerting on crypto operations"
        - "'We'll add logging later'"
      
      why_people_do_this: |
        **Common reasoning:**
        1. "Focused on functionality, not logging"
        2. "Logging adds complexity"
        3. "Not required for development"
        4. "Performance concerns"
        5. "Don't know what to log"
        
        **Root cause:** Treating audit as afterthought instead of requirement.
      
      consequences:
        
        immediate:
          - "Can't prove access controls work"
          - "No visibility into crypto operations"
          - "Can't detect anomalies"
        
        long_term:
          - "Compliance failures (SOC2, PCI-DSS, HIPAA)"
          - "Can't investigate incidents"
          - "Can't optimize permissions"
          - "Regulatory fines"
        
        real_cost: |
          **Incident example:**
          Breach detected 6 months after occurrence. No audit logs.
          
          Questions security couldn't answer:
          - Who accessed which secrets? (Unknown)
          - When did unauthorized access start? (Unknown)
          - What data was exfiltrated? (Unknown)
          - How did attacker move laterally? (Unknown)
          
          **Cost:** $8M breach response (6-month investigation), $3M regulatory 
          fines (no audit trail), customer exodus.
          
          With proper logging, breach would have been detected within hours, 
          not months. Cost would have been <$100K.
      
      how_to_avoid: |
        **Prevention:**
        
        1. **Log all crypto operations**
           ```python
           def sign(principal, key_id, data):
               # Pre-operation log
               request_id = audit_log(
                   principal=principal,
                   operation="sign",
                   resource=key_id,
                   timestamp=now(),
                   stage="attempt"
               )
               
               # Perform operation
               signature = kms.sign(key_id, data)
               
               # Post-operation log
               audit_log(
                   request_id=request_id,
                   stage="success",
                   duration_ms=elapsed
               )
               
               return signature
           ```
        
        2. **Required audit fields**
           - Timestamp (microsecond precision)
           - Principal (who)
           - Operation (what)
           - Resource (which key/resource)
           - Outcome (success/denied/failed)
           - Request ID (correlation)
        
        3. **Real-time monitoring**
           - Stream logs to SIEM
           - Alert on permission denials
           - Alert on sensitive operations (decrypt)
           - Dashboard for visibility
        
        4. **Compliance from day 1**
           - Build with audit requirements in mind
           - Not an afterthought
      
      how_to_fix_if_already_stuck: |
        **Remediation:**
        
        1. **Implement logging immediately**
           - Add audit logging to all crypto operations
           - Don't wait for "perfect" solution
           - Basic logging > no logging
        
        2. **Backfill where possible**
           - Check if CloudTrail or similar has history
           - Extract what's available
           - Document gaps
        
        3. **Set up monitoring**
           - Alert on permission denials
           - Alert on unusual patterns
           - Daily review of crypto operations
        
        4. **Compliance catch-up**
           - Document when logging started
           - Explain gap to auditors
           - Show current compliance
      
      real_world_example: |
        **Missing audit (bad):**
        ```python
        def decrypt_secret(key_id, ciphertext):
            # No logging!
            return kms.decrypt(key_id, ciphertext)
        ```
        
        **Complete audit (good):**
        ```python
        def decrypt_secret(principal, key_id, ciphertext):
            request_id = str(uuid.uuid4())
            
            # Pre-operation log
            audit_logger.log({
                "timestamp": datetime.utcnow().isoformat(),
                "request_id": request_id,
                "principal": principal,
                "operation": "decrypt",
                "resource": key_id,
                "stage": "attempt",
                "ip_address": get_client_ip(),
                "permissions": get_permissions(principal, key_id)
            })
            
            try:
                # Check permissions
                if not has_permission(principal, key_id, DECRYPT):
                    audit_logger.log({
                        "request_id": request_id,
                        "outcome": "denied",
                        "reason": "insufficient_permissions"
                    })
                    raise PermissionDeniedError()
                
                # Perform operation
                start = time.time()
                plaintext = kms.decrypt(key_id, ciphertext)
                duration = int((time.time() - start) * 1000)
                
                # Post-operation log
                audit_logger.log({
                    "request_id": request_id,
                    "outcome": "success",
                    "duration_ms": duration,
                    "result_size": len(plaintext)
                })
                
                # Alert if sensitive
                if is_sensitive_key(key_id):
                    alert_security_team({
                        "event": "sensitive_decrypt",
                        "principal": principal,
                        "key_id": key_id
                    })
                
                return plaintext
                
            except Exception as e:
                audit_logger.log({
                    "request_id": request_id,
                    "outcome": "failed",
                    "error": str(e)
                })
                raise
        ```
    
    mistake_4_permission_sprawl:
      
      name: "Accumulating Unused Permissions Over Time"
      
      what_it_looks_like:
        - "Services with permissions they no longer use"
        - "No permission reviews or audits"
        - "'Grant permission' but never 'revoke permission'"
        - "Permissions from old features still present"
      
      why_people_do_this: |
        **Common reasoning:**
        1. "Better to have permission and not need it..."
        2. "Don't want to break things by revoking"
        3. "No process for permission review"
        4. "Don't track what permissions are actually used"
        5. "Permission grants are easy, revocation is hard"
        
        **Root cause:** No lifecycle management for permissions.
      
      consequences:
        
        immediate:
          - "Services have more permissions than needed"
          - "Unclear what each service actually does"
          - "Violates least privilege"
        
        long_term:
          - "Permission creep compounds over time"
          - "Increased blast radius for each compromise"
          - "Audit complexity increases"
          - "Hard to enforce separation of duties"
        
        real_cost: |
          Service granted decrypt permission for one-time migration 3 years ago.
          Permission never revoked. Service compromised.
          
          Attacker had decrypt access service no longer needed or used.
          
          **Cost:** $1.2M from decrypt of data service shouldn't have accessed.
          
          Regular permission audits would have caught this.
      
      how_to_avoid: |
        **Prevention:**
        
        1. **Quarterly permission audits**
           ```bash
           # Compare granted vs used
           hsed audit compare-granted-vs-used --last-90-days
           
           # Identify unused permissions
           hsed audit find-unused --threshold 90d
           ```
        
        2. **Time-limited permissions**
           ```yaml
           service:
             permissions: 3
             granted: "2025-12-29T00:00:00Z"
             expires: "2026-01-29T00:00:00Z"  # 30 days
             auto_revoke: true
           ```
        
        3. **Justification required**
           ```yaml
           service:
             permissions: 12
             justification:
               H: "Verify build artifacts"
               S: "Sign production releases"
             last_reviewed: "2025-12-01"
             next_review: "2026-03-01"
           ```
        
        4. **Automated detection**
           - Alert on permissions unused >90 days
           - Require justification update
           - Auto-revoke after review period
      
      how_to_fix_if_already_stuck: |
        **Remediation:**
        
        1. **Analyze usage patterns (Week 1)**
           ```bash
           hsed audit analyze-usage \
             --start 2025-10-01 \
             --end 2025-12-29 \
             --output usage-report.json
           ```
        
        2. **Identify unused permissions (Week 2)**
           - Granted: 12 (H+S)
           - Actually used: 8 (H only)
           - Unused: S (sign permission)
        
        3. **Plan revocations (Week 3)**
           - Low-risk services first
           - Production services with testing
           - Break-glass fallback plan
        
        4. **Revoke gradually (Weeks 4-8)**
           - Week 4: Non-production
           - Week 5-6: Low-risk production
           - Week 7-8: High-risk production
        
        5. **Monitor (Weeks 9-12)**
           - Watch for permission errors
           - Restore if needed (with justification)
           - Document lessons learned
      
      real_world_example: |
        **Permission sprawl:**
        ```yaml
        # Service permissions over time
        
        2023-01-01:
          permissions: 8  # H (initial: verify only)
        
        2023-03-15:
          permissions: 12  # Added S for feature launch
        
        2023-06-20:
          permissions: 14  # Added E for "future use"
        
        2023-09-10:
          permissions: 15  # Added D for migration
        
        2025-12-29:
          permissions: 15  # Still has D (migration done 2 years ago!)
          actually_using: 12  # Only uses H+S
        ```
        
        **After cleanup:**
        ```yaml
        2025-12-29:
          permissions: 12  # Revoked E+D
          actually_using: 12  # Matches granted
          last_audit: "2025-12-29"
          next_audit: "2026-03-29"
          justification:
            H: "Verify artifacts - used daily"
            S: "Sign releases - used weekly"
        ```
    
    mistake_5_copy_paste_from_stack_overflow:
      
      name: "Using Unvalidated Examples from Stack Overflow"
      
      what_it_looks_like:
        - "IAM policies copied from internet examples"
        - "No understanding of what policy does"
        - "Over-permissive policies that 'just work'"
        - "'Found this on Stack Overflow, it works'"
      
      why_people_do_this: |
        **Common reasoning:**
        1. "Under pressure to deliver quickly"
        2. "Don't fully understand IAM"
        3. "Example works, why change it?"
        4. "Will review later" (never happens)
        5. "Security team not available for consultation"
        
        **Root cause:** Knowledge gap + time pressure = shortcuts.
      
      consequences:
        
        immediate:
          - "Over-permissive policies deployed"
          - "No understanding of security implications"
          - "Technical debt created"
        
        long_term:
          - "Security vulnerabilities in production"
          - "Policies become template for other services"
          - "Anti-patterns spread across organization"
          - "Difficult to audit or fix systematically"
        
        real_cost: |
          Developer copies AWS KMS policy from Stack Overflow with 
          "Resource": "*" and "Action": ["kms:*"].
          
          Policy grants access to ALL keys in account, not just intended one.
          
          Service compromised. Attacker accessed every KMS key in account.
          
          **Cost:** $4.2M from access to keys for multiple applications.
          
          Proper policy validation would have caught wildcard resources.
      
      how_to_avoid: |
        **Prevention:**
        
        1. **Policy validation in CI/CD**
           ```bash
           # Reject wildcards
           hsed validate \
             --reject-wildcard-principal \
             --reject-wildcard-resource \
             policies/
           ```
        
        2. **Documentation and training**
           - Provide organization-specific examples
           - Train developers on HSED
           - Security team code reviews
        
        3. **Policy templates**
           ```yaml
           # Organization-approved template
           # DO use this, DON'T copy from internet
           ci_cd_signing:
             role: hsed:signer
             permissions: 12
             resources:
               - "specific-key-id"  # Not "*"
           ```
        
        4. **Security review required**
           - All crypto policies reviewed before production
           - Rejected if wildcards or over-permissions
           - Feedback loop improves developer knowledge
      
      how_to_fix_if_already_stuck: |
        **Remediation:**
        
        1. **Scan for anti-patterns**
           ```bash
           # Find wildcard resources
           hsed audit find-wildcards
           
           # Find over-permissive policies
           hsed audit find-overpermissions
           ```
        
        2. **Review and understand each policy**
           - What does this policy actually grant?
           - Is this appropriate for the service?
           - Can we make it more specific?
        
        3. **Replace with proper policies**
           - Use HSED standard roles
           - Specific resources, not wildcards
           - Document why each permission needed
        
        4. **Educate team**
           - Share what was wrong with copied policies
           - Provide correct examples
           - Make it easier to do the right thing
      
      real_world_example: |
        **Stack Overflow copy-paste (bad):**
        ```json
        {
          "Effect": "Allow",
          "Action": ["kms:*"],
          "Resource": "*"
        }
        ```
        
        **What developer thought:** "Grants KMS access to my service"
        
        **What it actually does:** "Grants ALL KMS actions on ALL keys in account"
        
        **Proper HSED policy (good):**
        ```yaml
        service: ci-cd-pipeline
        role: hsed:signer
        permissions: 12  # H+S only
        resources:
          - "arn:aws:kms:us-east-1:123456789012:key/specific-signing-key"
        
        # Translates to:
        {
          "Effect": "Allow",
          "Action": [
            "kms:Sign",
            "kms:Verify",
            "kms:GetPublicKey",
            "kms:DescribeKey"
          ],
          "Resource": "arn:aws:kms:us-east-1:123456789012:key/specific-signing-key"
        }
        ```
  
  # --------------------------------------------------------------------------
  # Key Takeaways
  # --------------------------------------------------------------------------
  
  key_takeaways:
    
    critical_concepts:
      - "Mistake 1: Never grant root (15) to regular services. Start with 0, add minimum needed. Root is break-glass only."
      - "Mistake 2: Never combine Sign + Decrypt (13) without justification. Split into separate services for separation of duties."
      - "Mistake 3: Always log crypto operations. Complete audit trail is non-negotiable for compliance and security."
      - "Mistake 4: Audit permissions quarterly. Revoke unused permissions. Permission creep compounds over time."
      - "Mistake 5: Don't copy-paste from Stack Overflow. Validate policies, use organization templates, understand what you're granting."
    
    actionable_steps:
      - "Audit today: Find all services with root (15) or sign+decrypt (13). Create remediation plan."
      - "Implement logging now: Add audit logging to all crypto operations. Stream to SIEM, alert on anomalies."
      - "Schedule quarterly reviews: Check granted vs used permissions. Revoke unused. Update justifications."
    
    common_pitfalls_summary:
      - "Don't grant permissions 'just to be safe' - that's how you end up with root everywhere"
      - "Don't combine responsibilities in one service - separation of duties prevents complete compromise"
      - "Don't skip logging 'temporarily' - temporary becomes permanent, compliance failures result"
      - "Don't let permissions accumulate - unused permissions are security debt"
      - "Don't copy unvalidated examples - understand and validate everything you deploy"
    
    remember_this:
      - "Root is break-glass, not default"
      - "Split duties across services, not accumulate in one"
      - "Audit everything, always, from day one"
      - "Review quarterly, revoke unused"
      - "Validate everything, trust nothing from internet"
    
    next_steps:
      - "Chapter 1 complete! You now understand HSED fundamentals."
      - "Chapter 2: Deep dive into each permission bit with cryptographic foundations"
      - "Chapter 3: Advanced implementation patterns and production deployment"
      - "Apply HSED to your systems: Start with one service, validate, expand"

---
