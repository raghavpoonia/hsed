# section_1_08_role_hierarchies.yaml
---
document_info:
  chapter: "1"
  section: "08"
  title: "Role Hierarchies and Permission Inheritance"
  version: "1.0.0"
  author: "Raghav Dinesh"
  github: "github.com/raghavpoonia"
  license: "MIT"
  created: "2025-12-29"
  estimated_pages: 5
  tags: ["hsed", "role-hierarchies", "inheritance", "permission-creep", "organizational-structure"]

# ============================================================================
# SECTION 1.08: ROLE HIERARCHIES AND PERMISSION INHERITANCE
# ============================================================================

section_1_08_role_hierarchies:
  
  # --------------------------------------------------------------------------
  # Overview and Context
  # --------------------------------------------------------------------------
  
  overview: |
    Real organizations have hierarchies: junior developers, senior developers, 
    team leads, managers. Does HSED need to mirror these hierarchies with 
    permission inheritance? Should "senior engineer" automatically include all 
    "junior engineer" permissions plus more?
    
    Short answer: **Be very careful.** Permission hierarchies can help or hurt, 
    depending on how you design them.
    
    This section covers:
    - When hierarchies make sense (rarely)
    - When flat roles work better (usually)
    - How to avoid permission creep in hierarchies
    - Patterns that work vs patterns that fail
    
    By the end, you'll know whether your organization needs role hierarchies, 
    or whether flat roles (the standard hsed:signer, hsed:vault, etc.) are 
    sufficient.
  
  # --------------------------------------------------------------------------
  # Core Concepts
  # --------------------------------------------------------------------------
  
  core_concepts:
    
    flat_role_model:
      
      definition: |
        **Flat Role Model**: Every role has explicitly defined permissions, with 
        no inheritance. Role A doesn't automatically include Role B's permissions.
        
        In HSED:
        ```yaml
        roles:
          signer:
            permissions: 12  # H+S
          
          vault:
            permissions: 3   # E+D
          
          audit:
            permissions: 9   # H+D
        ```
        
        Each role is independent. No hierarchy. No inheritance.
      
      why_it_matters: |
        Flat models are simpler and safer:
        
        **Advantages:**
        1. **Explicit permissions**: Always know exactly what a role can do
        2. **No hidden inheritance**: Can't accidentally grant extra permissions
        3. **Easy to audit**: Role → permissions mapping is direct
        4. **Separation of duties preserved**: No accumulation of incompatible permissions
        
        **Disadvantages:**
        1. **Can't express "senior = junior + more"**: Need separate roles
        2. **More roles**: Junior and senior need different role names
        3. **Manual grants**: Can't say "grant all junior roles"
        
        For most organizations, flat roles are the right choice.
      
      key_components:
        
        explicit_role_definition:
          what: "Every role fully defines its permissions"
          no_defaults: "No implicit inheritance or defaults"
          example: |
            # Flat model - explicit permissions
            junior_developer:
              permissions: 0  # No crypto access
            
            senior_developer:
              permissions: 8  # H only (verify signatures)
            
            lead_developer:
              permissions: 12  # H+S (verify and sign)
            
            # Senior doesn't automatically get lead permissions
        
        role_assignment:
          what: "Users assigned to specific roles, no hierarchy"
          method: "Direct assignment, no inheritance"
          example: |
            users:
              alice:
                roles: ["junior_developer"]
                permissions: 0  # From junior_developer role
              
              bob:
                roles: ["senior_developer"]
                permissions: 8  # From senior_developer role
              
              carol:
                roles: ["lead_developer"]
                permissions: 12  # From lead_developer role
        
        permission_computation:
          what: "User's permissions = OR of all assigned role permissions"
          formula: "permissions = role1 | role2 | role3"
          example: |
            user:
              roles: ["verifier", "encryptor"]
            
            # Verifier: 8 (H)
            # Encryptor: 2 (E)
            # Combined: 8 | 2 = 10 (H+E)
            
            # User can hash and encrypt
      
      how_it_works: |
        **Flat role assignment:**
        
        1. **Define roles explicitly**
           - Each role has exact permissions
           - No dependencies or inheritance
        
        2. **Assign users to roles**
           - User can have multiple roles
           - Permissions combine via OR
        
        3. **Compute effective permissions**
           - effective = role1 | role2 | ... | roleN
           - Simple bitwise OR operation
        
        4. **Check permissions**
           - Use computed effective permissions
           - No hierarchy traversal needed
      
      real_world_example: |
        **Startup with flat role model:**
        
        ```yaml
        roles:
          developer:
            permissions: 8  # H (verify builds)
            description: "All developers can verify signatures"
          
          release_manager:
            permissions: 12  # H+S (verify and sign releases)
            description: "Release managers sign production deployments"
          
          security_team:
            permissions: 9  # H+D (verify and decrypt for audits)
            description: "Security team investigates incidents"
          
          devops:
            permissions: 3  # E+D (manage secrets)
            description: "DevOps manages infrastructure secrets"
        
        users:
          alice:
            roles: ["developer"]
            # Can: Verify signatures
            # Cannot: Sign, encrypt, decrypt
          
          bob:
            roles: ["developer", "release_manager"]
            # Can: Verify, sign (8 | 12 = 12)
            # Cannot: Encrypt, decrypt
          
          carol:
            roles: ["security_team"]
            # Can: Verify, decrypt
            # Cannot: Sign, encrypt
          
          dave:
            roles: ["developer", "devops"]
            # Can: Verify, encrypt, decrypt (8 | 3 = 11)
            # Cannot: Sign
        ```
        
        **Properties:**
        - Clear: Each role's permissions explicit
        - Safe: No hidden inheritance
        - Flexible: Multiple role assignment handles edge cases
        - Auditable: Easy to verify who can do what
      
      related_concepts:
        - "RBAC (Role-Based Access Control): Standard access control model"
        - "Explicit grants: No implicit permissions"
        - "Composition over inheritance: Combine roles vs inherit"
    
    hierarchical_role_model:
      
      definition: |
        **Hierarchical Role Model**: Roles form a hierarchy where child roles 
        inherit parent permissions. Senior roles automatically include all junior 
        permissions.
        
        In HSED:
        ```yaml
        roles:
          junior:
            permissions: 0
          
          mid:
            inherits: [junior]
            additional_permissions: 8  # H
            effective_permissions: 0 | 8 = 8
          
          senior:
            inherits: [mid]
            additional_permissions: 4  # S
            effective_permissions: 0 | 8 | 4 = 12
        ```
        
        Each level inherits permissions from levels below.
      
      why_it_matters: |
        Hierarchies match organizational structure but create problems:
        
        **Advantages:**
        1. **Mirrors org chart**: Easy to understand for HR
        2. **Promotion = automatic permission gain**: One change propagates
        3. **Fewer explicit grants**: Inheritance handles it
        
        **Disadvantages (critical):**
        1. **Permission creep**: Senior accumulates all junior permissions (may not need)
        2. **Violates least privilege**: Inherit permissions you don't use
        3. **Violates separation of duties**: Can accumulate incompatible permissions
        4. **Hard to audit**: Need to traverse hierarchy to compute permissions
        5. **Hidden complexity**: Changes to parent affect all children
        
        **Verdict:** Avoid hierarchical models for cryptographic permissions. 
        Organizational hierarchy ≠ permission hierarchy.
      
      key_components:
        
        inheritance_patterns:
          single_inheritance: "Each role has one parent"
          multiple_inheritance: "Role can inherit from multiple parents"
          transitive_inheritance: "Inherit from parents and grandparents"
          example: |
            # Single inheritance
            junior → mid → senior → principal
            
            # Multiple inheritance (dangerous)
            tech_lead:
              inherits: [senior_engineer, security_specialist]
              # Accumulates both permission sets
        
        permission_accumulation:
          what: "Permissions accumulate up the hierarchy"
          formula: "effective = own | parent | grandparent | ..."
          problem: "Can't remove permissions, only add"
          example: |
            junior: 0
            mid: 0 | 8 = 8
            senior: 0 | 8 | 4 = 12
            principal: 0 | 8 | 4 | 2 = 14
            # Principal has E (encrypt) - do they need it?
        
        promotion_problem:
          what: "Promotion grants all higher-level permissions"
          issue: "May grant unneeded permissions"
          example: |
            alice:
              role: senior_engineer  # permissions: 12 (H+S)
            
            # Promoted to principal
            alice:
              role: principal_engineer  # permissions: 14 (H+S+E)
            
            # Alice now has Encrypt permission
            # Does she need it? Maybe not.
            # Permission creep via promotion
      
      how_it_works: |
        **Hierarchical permission computation:**
        
        1. **Start with role**
           - Get role's direct permissions
        
        2. **Traverse to parents**
           - Add each parent's permissions
           - Recursively traverse to grandparents
        
        3. **Combine via OR**
           - effective = own | parent1 | parent2 | ...
        
        4. **Cache computed permissions**
           - Don't recompute every time
           - Invalidate cache on hierarchy changes
      
      real_world_example: |
        **Failed hierarchy: Permission creep**
        
        ```yaml
        # Initial design (seemed logical)
        roles:
          junior_engineer:
            permissions: 0
          
          engineer:
            inherits: [junior_engineer]
            permissions: 8  # H (verify)
          
          senior_engineer:
            inherits: [engineer]
            permissions: 4  # S (sign)
            # Effective: 0 | 8 | 4 = 12 (H+S)
          
          principal_engineer:
            inherits: [senior_engineer]
            permissions: 2  # E (encrypt)
            # Effective: 0 | 8 | 4 | 2 = 14 (H+S+E)
          
          staff_engineer:
            inherits: [principal_engineer]
            permissions: 1  # D (decrypt)
            # Effective: 0 | 8 | 4 | 2 | 1 = 15 (ROOT!)
        ```
        
        **Problem discovered:**
        - Staff engineer has ROOT permissions (15)
        - Violates least privilege
        - Violates separation of duties
        - Most staff engineers don't need decrypt
        - Some need decrypt, but not encrypt or sign
        
        **Better flat design:**
        ```yaml
        roles:
          # Role based on function, not seniority
          verifier:
            permissions: 8  # Anyone who needs to verify
          
          signer:
            permissions: 12  # Release managers (any seniority)
          
          secrets_admin:
            permissions: 3  # DevOps (any seniority)
          
          auditor:
            permissions: 9  # Security team (any seniority)
        
        # Assign by function, not title
        users:
          alice:
            title: "Senior Engineer"
            roles: ["verifier", "signer"]  # Release manager duties
          
          bob:
            title: "Staff Engineer"
            roles: ["verifier"]  # Only needs verify
          
          carol:
            title: "Principal Engineer"
            roles: ["auditor"]  # Security-focused principal
        ```
        
        **Lesson:** Job title ≠ crypto permissions. Function determines permissions.
      
      related_concepts:
        - "Permission creep: Accumulation of unnecessary permissions over time"
        - "Organizational hierarchy: Structure of reporting relationships"
        - "Functional roles: Permissions based on what you do, not title"
    
    when_to_use_each:
      
      definition: |
        **Decision framework**: Flat vs hierarchical role models
        
        **Use flat model (recommended):**
        - Cryptographic permissions (HSED)
        - Security-sensitive operations
        - When separation of duties critical
        - When audit clarity important
        
        **Use hierarchical model (rarely):**
        - Non-security permissions (read reports, edit wiki)
        - When organizational structure directly maps to permissions
        - When permission creep is not a concern
        - When inheritance simplifies management significantly
      
      why_it_matters: |
        Wrong model choice creates security debt:
        
        **Hierarchy for crypto = Security problems:**
        - Permission creep is inevitable
        - Separation of duties violations
        - Audit complexity
        - Hard to revoke (affects hierarchy)
        
        **Flat for crypto = Security clarity:**
        - Explicit permissions
        - Audit-friendly
        - Separation maintained
        - Easy to revoke
      
      decision_criteria:
        
        use_flat_when:
          - "Permissions control cryptographic operations"
          - "Least privilege is critical"
          - "Separation of duties required"
          - "Regular compliance audits"
          - "Multiple teams with different needs"
        
        use_hierarchy_when:
          - "Permissions for non-sensitive operations"
          - "Organizational structure directly maps to access needs"
          - "Promotions should automatically grant access"
          - "Management wants 'simple' org-chart-based model"
        
        never_use_hierarchy_when:
          - "HSED permissions (crypto operations)"
          - "Root/admin access involved"
          - "Compliance regulations apply (SOC2, PCI-DSS, HIPAA)"
          - "Breach would have serious consequences"
      
      real_world_example: |
        **Good use of hierarchy (non-crypto):**
        
        ```yaml
        # Document access permissions (non-crypto)
        roles:
          employee:
            permissions: ["read_company_docs"]
          
          manager:
            inherits: [employee]
            permissions: ["read_team_reports", "approve_pto"]
          
          director:
            inherits: [manager]
            permissions: ["read_all_reports", "approve_budget"]
        ```
        
        **This is fine because:**
        - Not security-sensitive (documents, not crypto keys)
        - Promotions naturally grant more document access
        - No separation of duties concerns
        - No compliance implications
        
        **Bad use of hierarchy (crypto):**
        
        ```yaml
        # WRONG: Crypto permissions with hierarchy
        roles:
          developer:
            permissions: 8  # H
          
          senior_developer:
            inherits: [developer]
            permissions: 4  # S
            # Effective: 12 (H+S)
          
          architect:
            inherits: [senior_developer]
            permissions: 3  # E+D
            # Effective: 15 (ROOT!) - DISASTER
        ```
        
        **This is bad because:**
        - Architect has root crypto access
        - Violates least privilege
        - Can't audit easily
        - Promotion = automatic permission escalation
        
        **Correct flat design:**
        
        ```yaml
        # Flat model for crypto
        roles:
          verifier:
            permissions: 8
          
          signer:
            permissions: 12
          
          secrets_admin:
            permissions: 3
        
        # Assign by function
        users:
          alice:
            title: "Architect"
            roles: ["verifier"]  # Only what she needs
        ```
      
      related_concepts:
        - "Context-specific design: Different models for different domains"
        - "Security-sensitive vs non-sensitive permissions"
        - "Principle of appropriate abstraction"
  
  # --------------------------------------------------------------------------
  # Practical Implementation
  # --------------------------------------------------------------------------
  
  practical_implementation:
    
    avoiding_permission_creep:
      
      overview: "Strategies to prevent accumulation of unnecessary permissions"
      
      prevention_strategies:
        
        regular_permission_audits:
          frequency: "Quarterly"
          process: "Review granted vs used permissions"
          action: "Revoke unused permissions"
          example: |
            # Q1 Audit
            user: alice
            granted: 14 (H+S+E)
            actually_used: 12 (H+S)
            action: Revoke E permission → new: 12
        
        just_in_time_permissions:
          what: "Grant permissions when needed, revoke after"
          duration: "Hours to days, not permanent"
          use_case: "Migrations, incident response, one-time tasks"
          example: |
            # Migration task
            alice:
              temporary_permissions: 3  # E+D for migration
              expires: "2025-12-30T00:00:00Z"
              auto_revoke: true
            
            # After expiry
            alice:
              permissions: 8  # Back to normal (H only)
        
        role_based_not_title_based:
          principle: "Permissions based on function, not job title"
          example: |
            # Wrong: Title-based
            alice:
              title: "Principal Engineer"
              permissions: 15  # All principals get root?
            
            # Right: Function-based
            alice:
              title: "Principal Engineer"
              function: "Release Management"
              permissions: 12  # Signer role
        
        explicit_justification:
          requirement: "Document why permission needed"
          review: "Justification reviewed during audits"
          example: |
            alice:
              permissions: 12
              justification:
                H: "Verify build artifacts before signing"
                S: "Sign production releases"
                E: "N/A - doesn't handle secrets"
                D: "N/A - doesn't access encrypted data"
      
      complete_example: |
        **Permission lifecycle management:**
        
        ```yaml
        # Initial grant (minimal)
        new_hire:
          user: bob
          role: "junior_developer"
          permissions: 0
          justification: "New hire, no crypto access needed"
        
        # Temporary elevation (time-limited)
        migration_task:
          user: bob
          additional_permissions: 3  # E+D for data migration
          granted: "2025-12-29T09:00:00Z"
          expires: "2025-12-29T17:00:00Z"
          justification: "One-time customer data migration"
          auto_revoke: true
        
        # Role change (function-based)
        promotion:
          user: bob
          old_role: "junior_developer"
          new_role: "senior_developer"
          permissions: 8  # H (verify signatures)
          justification: "Code review responsibilities require verification"
        
        # Quarterly audit
        q1_audit:
          user: bob
          granted: 8  # H
          used: 8  # H
          action: "Keep - actively used"
        
        # Role change (function, not title)
        lateral_move:
          user: bob
          title: "Staff Engineer"  # Promotion
          old_function: "Backend Development"
          new_function: "Security Engineering"
          old_permissions: 8  # H
          new_permissions: 9  # H+D (audit role)
          justification: "Security role requires decrypt for investigations"
        ```
  
  # --------------------------------------------------------------------------
  # Key Takeaways
  # --------------------------------------------------------------------------
  
  key_takeaways:
    
    critical_concepts:
      - "Flat roles (recommended): Explicit permissions, no inheritance. Use hsed:signer, hsed:vault, hsed:audit as-is."
      - "Hierarchical roles (avoid for crypto): Permission creep, separation of duties violations, audit complexity."
      - "Job title ≠ crypto permissions: Assign by function (what they do), not title (where they are in org chart)."
      - "Regular audits prevent creep: Quarterly review of granted vs used permissions. Revoke unused aggressively."
    
    actionable_steps:
      - "Use flat HSED roles: Don't create engineer→senior→principal hierarchy for crypto. Use functional roles: verifier, signer, vault, audit."
      - "Audit quarterly: Check if all granted permissions still needed. Revoke unused. Just-in-time for temporary needs."
      - "Document justifications: Every permission needs a 'why'. Review justifications during audits."
    
    common_pitfalls_summary:
      - "Don't mirror org chart with crypto permissions - organizational hierarchy ≠ permission hierarchy"
      - "Don't let promotions automatically grant permissions - review and assign explicitly based on new function"
      - "Don't skip permission audits - unused permissions accumulate into security debt"
    
    remember_this:
      - "Flat beats hierarchical for crypto permissions"
      - "Function determines permissions, not title"
      - "Audit quarterly, revoke unused, justify everything"
    
    next_steps:
      - "Section 1.09 applies everything to real scenarios: CI/CD, secrets management, audit systems"
      - "Section 1.10 catalogs common mistakes and anti-patterns to avoid"
      - "Chapter 2 dives deep into each permission bit with cryptographic foundations"

---
